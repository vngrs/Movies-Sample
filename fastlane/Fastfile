# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

# export LC_ALL=en_US.UTF-8
# export LANG=en_US.UTF-8

PRODUCE_APP_IDENTIFIER = "com.vngrs.Movies.demo"

module ReleaseTagPrefix
  FIREBASE = "firebase/"
  APPSTORE = "appstore/"
end

fastlane_require = "dotenv"

before_all do
  # update_fastlane
  Dotenv.load ".env.secret"
end

default_platform(:ios)

platform :ios do

  before_all do

    # ENV["SLACK_URL"] = "https://hooks.slack.com/services/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" # ci
    #ENV["SLACK_URL"] = "https://hooks.slack.com/services/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" # mafp_mobile_qa
    #ENV["SLACK_URL"] = "https://hooks.slack.com/services/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" # maf-properties

    # Testing Web Hook .. Don't use
    #ENV["SLACK_URL"] = "https://hooks.slack.com/services/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"

  end

  #---------------------- SIGNING LANES ------------------------------#

  lane :certs_all do

    certs_dev
    certs_beta
    certs_appstore
  end

  desc "Fetches the provisioning profiles so you can build locally and deploy to your device"
  lane :certs_dev do

    match(
      app_identifier: ENV["PRODUCE_APP_IDENTIFIER"],
      type: "development",
      force_for_new_devices: true,
      readonly: true
    )
  end

  desc "Fetches the provisioning profiles so you can build for beta or appstore distribution"
  lane :certs_beta do

    match(
      app_identifier: ENV["PRODUCE_APP_IDENTIFIER"],
      type: "adhoc",
      force_for_new_devices: true,
      readonly: true
    )
  end

  desc "AppStore signing"
  lane :certs_appstore do

    match(
      app_identifier: ENV["PRODUCE_APP_IDENTIFIER"],
      type: "appstore",
      readonly: true
    )
  end

  #---------------------- PUBLIC LANES ------------------------------#
  #---------------------- AppStore LANES ------------------------------#

  desc "AppStore Distribution"
  lane :go_testflight do |params|

    build_config = "Release"
    schemes = {
      "Movies" => "com.vngrs.Movies.demo"
    }
    build(schemes: schemes, config: build_config, export: "app-store", bitcode: true)
    upload_testflight(schemes: schemes)
    increment_version
    upload_dsyms
  end

  #---------------------- Firebase LANES ------------------------------#

  desc "Firebase App Distribution"
  lane :go_firebase do

    build_config = "AdHoc"
    schemes = {
      "Movies" => "com.vngrs.Movies.demo"
    }

    build(schemes: schemes, config: build_config, export: "ad-hoc", bitcode: false)
    upload_firebase(schemes: schemes)
    # post_beta_to_slack(config: build_config)
    increment_version
  end

  #---------------------- DSYMS LANES ------------------------------#

  desc "Upload any dsyms in the current directory to crashlytics"
  lane :upload_dsyms do |options|

    version_number = get_version_number(target: "Movies")
    build_number = get_build_number
    download_dsyms(
      app_identifier: "com.vngrs.Movies.demo",
      version: version_number,
      build_number: build_number
    )
    upload_symbols_to_crashlytics(gsp_path: "./Movies/Resources/GoogleService-Info.plist")
    # clean_build_artifacts
  end

  #---------------------- PRIVATE LANES ------------------------------#

  desc "build"
  private_lane :build do |params|

    export_method = params[:export]
    include_bitcode = params[:bitcode]

    puts export_method
    puts include_bitcode

    params[:schemes].each do | scheme, app_id |

    version = get_build_number
    ipa_name = "#{scheme}_#{version}"
    ipa_path = "../#{ipa_name}.ipa"
    build_config = params[:config]

      if !File.file?(ipa_path)

        # Build only if ipa not found
        gym(
          clean: true,
          configuration: build_config,
          scheme: scheme,
          workspace: "Movies.xcworkspace",
          export_method: export_method,
          output_name: ipa_name,
          include_bitcode: include_bitcode
        )
      else
        puts "#{ipa_name}.ipa already exists. Skipping GYM"
      end
    end
  end

  private_lane :upload_firebase do |params|

    params[:schemes].each do | scheme, app_id |

    version = get_build_number
    path = "#{scheme}_#{version}.ipa"

    puts path
    firebase_app_distribution(
        app: "1:141663741646:ios:f14686d984c8a3128ad29f",
        groups: "Developers, Testers",
        release_notes: "Lots of amazing new features to test out!",
        firebase_cli_path: "/usr/local/bin/firebase",
        ipa_path: path,
        debug: true
    )
    end
  end

  private_lane :upload_testflight do |params|

    version = get_build_number
    params[:schemes].each do | scheme, app_id |

      path = "#{scheme}_#{version}.ipa"

      upload_to_testflight(
        beta_app_feedback_email: "obada@vngrs.com",
        notify_external_testers: true,
        ipa: path,
        skip_submission: true,
        skip_waiting_for_build_processing: true,
        username: "obada@vngrs.com"
      )
    end
  end

  # ============================ VERSION CONTROL ============================#

  lane :set_version do |params|

    version = params[:v]

    increment_build_number
    increment_version_number(version_number: version)
    commit_version_bump(message:"Prepare version v#{version} for next release", force: true, xcodeproj: "Movies.xcodeproj")
  end

  lane :increment_build do

    version = get_version_number(target: "Movies")
    increment_build_number
    build_number_after_increment = get_build_number
    commit_version_bump(message:"New build #{build_number_after_increment} - version v#{version} [skip ci]", force: true, xcodeproj: "Movies.xcodeproj")
    push_to_git_remote
  end

  lane :increment_version do

    # Incrementing version number is taking place after the successful build, to avoid the need to clean up
    # after a failing build for any reason...

    increment_build_number
    build_number_after_increment = get_build_number
    commit_version_bump(message:"Prepare build for next release build: #{build_number_after_increment}", force: true, xcodeproj: "Movies.xcodeproj")
    push_to_git_remote
  end

  # ============================ REGISTER DEVICES ============================#

  lane :register_new_devices do

    register_devices(devices_file: "./devices.txt")
    # register_devices(
    #   devices: {
    #     "Obada's iPhone 6" => "311e160f0e45a353eee276a000a90c72b342c2f1",
    #     "Test iPhone 7 Plus" => "47967909d0b90df7d3444d2bbb8b44233475eba5",
    #     "Ahmed Abdurrahman" => "00008020-001A0C381ED8003A",
    #   }
    # )
    certs_all
  end

  #  ===============================   CI Lanes

  desc "Firebase App Distribution"
  lane :ci_adhoc_build do

    build_config = "AdHoc"
    schemes = {
      "Movies" => "com.vngrs.Movies.demo"
    }
    auto_increment_version(tagPrefix: ReleaseTagPrefix::FIREBASE)
    ci_build(schemes: schemes, config: build_config, export: "ad-hoc", bitcode: false)
  end

  desc "CI build"
  private_lane :ci_build do |params|

    export_method = params[:export]
    include_bitcode = params[:bitcode]

    puts export_method
    puts include_bitcode

    params[:schemes].each do | scheme, app_id |

    version = get_build_number
    ipa_name = "build"
    ipa_path = "../build.ipa"
    build_config = params[:config]
    gym(
          clean: true,
          configuration: build_config,
          scheme: scheme,
          workspace: "Movies.xcworkspace",
          export_method: export_method,
          output_name: ipa_name,
          include_bitcode: include_bitcode
        )
    end
  end

  lane :test do

      auto_increment_version(
        tagPrefix: ReleaseTagPrefix::FIREBASE
      )
  end

  lane :auto_increment_version do |params|

      sh("git fetch --tags")
      analyze_commits(match: "#{params[:tagPrefix]}*")
      increment_build_number
      @BUILD_NUMBER = get_build_number
      @VERSION_NUMBER = lane_context[SharedValues::RELEASE_NEXT_VERSION]
      puts "NEW VERSION >>> #{@VERSION_NUMBER} #{@BUILD_NUMBER}"
      increment_version_number(version_number: @VERSION_NUMBER)
  end

  lane :populate_changelog do

      changelogForMessage = conventional_changelog(title: "Changelog", format: 'slack',  display_links: false)
      puts changelogForMessage
      sh("envman add --key CHANGE_LOG --value \"#{changelogForMessage}\"")
  end

  lane :push_new_version do # Should run only AFTER a successful build

      commit_version_bump(message:"New version: #{@VERSION_NUMBER} #{@BUILD_NUMBER}", force: true, xcodeproj: "Movies.xcodeproj")
      add_git_tag("#{ReleaseTagPrefix::FIREBASE}#{@VERSION_NUMBER}")
      push_to_git_remote(tags: true)
  end
end
